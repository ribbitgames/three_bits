<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marble Madness</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            touch-action: none;
        }
        #ui-container {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 2;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        #timer {
            margin-bottom: 8px;
            font-weight: bold;
        }
        #level-info {
            font-size: 16px;
            opacity: 0.9;
            margin-bottom: 8px;
        }
        #score {
            font-size: 16px;
            color: #FFD700;
            font-weight: bold;
        }
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 60, 114, 0.8));
            color: white;
            z-index: 3;
            backdrop-filter: blur(20px);
        }
        h1 {
            margin-bottom: 30px;
            font-size: 48px;
            text-align: center;
            background: linear-gradient(45deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
        }
        .game-info {
            text-align: center;
            margin-bottom: 30px;
            font-size: 18px;
            line-height: 1.6;
            max-width: 600px;
            opacity: 0.9;
        }
        button {
            padding: 18px 36px;
            font-size: 20px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            touch-action: manipulation;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
            font-weight: bold;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }
        button:active {
            transform: translateY(0);
        }
        #joystick-base {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            border: 3px solid rgba(255, 255, 255, 0.4);
            display: none;
            z-index: 5;
            transform: translate(-50%, -50%);
            touch-action: none;
            pointer-events: none;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
        }
        #joystick-knob {
            width: 60px;
            height: 60px;
            background: linear-gradient(45deg, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.7));
            border-radius: 50%;
            position: absolute;
            top: 30px;
            left: 30px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
        }
        #controls-help {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            opacity: 0.8;
            z-index: 2;
        }
        #surface-legend {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.4);
            color: white;
            padding: 12px;
            border-radius: 10px;
            font-size: 12px;
            z-index: 2;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 6px;
        }
        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.9), rgba(0, 0, 0, 0.8));
            color: white;
            z-index: 3;
            backdrop-filter: blur(20px);
        }
        
        #level-complete-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, rgba(0, 139, 0, 0.9), rgba(0, 50, 0, 0.8));
            color: white;
            z-index: 3;
            backdrop-filter: blur(20px);
        }
        
        .screen-title {
            margin-bottom: 20px;
            font-size: 36px;
            text-align: center;
            font-weight: bold;
        }
        
        .screen-message {
            text-align: center;
            margin-bottom: 30px;
            font-size: 18px;
            line-height: 1.5;
        }
        
        .button-container {
            display: flex;
            gap: 20px;
        }
        
        .secondary-button {
            padding: 18px 36px;
            font-size: 20px;
            background: linear-gradient(45deg, #666, #555);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            touch-action: manipulation;
            box-shadow: 0 4px 15px rgba(102, 102, 102, 0.3);
            font-weight: bold;
        }
        
        .secondary-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 102, 102, 0.4);
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        .pulse-animation {
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="ui-container">
            <div id="timer">Time: <span id="time-value">60</span></div>
            <div id="level-info">Level <span id="level-number">1</span></div>
            <div id="score">Score: <span id="score-value">0</span></div>
            <div id="joystick-base">
                <div id="joystick-knob"></div>
            </div>
        </div>
        <div id="surface-legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #32CD32;"></div>
                <span>Start/Goal</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ADD8E6;"></div>
                <span>Ice (Slippery)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #8B4513;"></div>
                <span>Sticky (Slow)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FF0000;"></div>
                <span>Acid (Death)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #9370DB;"></div>
                <span>Elevated</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FFD700;"></div>
                <span>Coin (+100)</span>
            </div>
        </div>
        <div id="controls-help">
            Touch/Click and drag to move marble
        </div>
        <div id="start-screen">
            <h1>Marble Madness</h1>
            <div class="game-info">
                Navigate your marble through infinite levels!<br>
                Avoid slinkies, acid, and falling off edges.<br>
                Collect coins for bonus points!
            </div>
            <button id="start-button" class="pulse-animation">Start Adventure</button>
        </div>
        
        <div id="game-over-screen">
            <div class="screen-title">Game Over!</div>
            <div class="screen-message">
                Your marble was destroyed!<br>
                Score: <span id="final-score">0</span>
            </div>
            <div class="button-container">
                <button id="restart-level-button">Restart Level</button>
                <button id="main-menu-button" class="secondary-button">Main Menu</button>
            </div>
        </div>
        
        <div id="level-complete-screen">
            <div class="screen-title">Level Complete!</div>
            <div class="screen-message">
                Excellent work!<br>
                Level <span id="completed-level">1</span> finished<br>
                Score: <span id="level-score">0</span>
            </div>
            <div class="button-container">
                <button id="next-level-button">Next Level</button>
                <button id="menu-button" class="secondary-button">Main Menu</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const GAME_STATE = { MENU: 0, PLAYING: 1, GAME_OVER: 2, WIN: 3 };
        const SETTINGS = { marbleRadius: 0.5, cameraDistance: 15, timeLimit: 60, gravity: 0.015, iceMultiplier: 1.5, stickyMultiplier: 0.5, enemyStartLevel: 3 };
        const SURFACE = { NONE: 0, NORMAL: 1, START: 2, GOAL: 3, ICE: 4, STICKY: 5, ENEMY: 6, ACID: 7, ELEVATED: 8, COIN: 9 };

        let renderer, scene, camera, marble, levelGroup, startTime, timeLeft;
        let gameState = GAME_STATE.MENU;
        let marbleVelocity = { x: 0, z: 0, y: 0 };
        let enemies = [], coins = [], isJumping = false, isFalling = false, currentLevel = 1, enemySpeed = 0.02;
        let cameraTargetPosition = new THREE.Vector3(), cameraSmoothing = 0.1;
        let joystickActive = false, joystickOrigin = { x: 0, y: 0 }, joystickVector = { x: 0, y: 0 }, currentPointerType = null;
        let score = 0;

        const joystickBase = document.getElementById('joystick-base');
        const joystickKnob = document.getElementById('joystick-knob');
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const gameOverScreen = document.getElementById('game-over-screen');
        const levelCompleteScreen = document.getElementById('level-complete-screen');
        const restartLevelButton = document.getElementById('restart-level-button');
        const mainMenuButton = document.getElementById('main-menu-button');
        const nextLevelButton = document.getElementById('next-level-button');
        const menuButton = document.getElementById('menu-button');
        const timeValue = document.getElementById('time-value');
        const levelNumber = document.getElementById('level-number');
        const scoreValue = document.getElementById('score-value');
        const finalScore = document.getElementById('final-score');
        const levelScore = document.getElementById('level-score');
        const completedLevel = document.getElementById('completed-level');

        function init() {
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x001122);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            scene = new THREE.Scene();
            const aspect = window.innerWidth / window.innerHeight;
            const viewSize = window.innerHeight > window.innerWidth ? 10 : 5;
            camera = new THREE.OrthographicCamera(-viewSize * aspect, viewSize * aspect, viewSize, -viewSize, 0.1, 1000);
            camera.position.set(SETTINGS.cameraDistance, SETTINGS.cameraDistance, SETTINGS.cameraDistance);
            camera.lookAt(0, 0, 0);

            scene.add(new THREE.AmbientLight(0x404080, 0.4));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            setupEventListeners();
            animate();
        }

        class SeededRandom {
            constructor(seed) { this.seed = seed; }
            random() { const x = Math.sin(this.seed++) * 10000; return x - Math.floor(x); }
            randomInt(min, max) { return Math.floor(this.random() * (max - min + 1)) + min; }
            randomBool(probability = 0.5) { return this.random() < probability; }
        }

        function generateProceduralLevel(level) {
            const rng = new SeededRandom(level * 1000 + Math.floor(Math.random() * 1000));
            const width = 10 + Math.min(8, Math.floor(level * 0.3));
            const height = 15 + Math.min(10, Math.floor(level * 0.4));
            let grid = Array(height).fill().map(() => Array(width).fill(SURFACE.NONE));

            const params = {
                ice: Math.min(0.02 + (level - 1) * 0.02, 0.15),
                sticky: Math.min(0.02 + (level - 1) * 0.015, 0.12),
                acid: level > 1 ? Math.min(0.01 + (level - 2) * 0.015, 0.10) : 0,
                elevated: Math.min(0.02 + (level - 1) * 0.02, 0.15),
                empty: Math.min(0.08 + (level - 1) * 0.015, 0.20),
                coins: Math.min(0.03 + (level - 1) * 0.01, 0.08),
                enemies: level >= SETTINGS.enemyStartLevel ? Math.min(level - SETTINGS.enemyStartLevel + 1, 8) : 0,
                pathTurns: 3 + Math.min(level, 10),
                pathWidth: Math.max(2, 5 - Math.floor(level / 3))
            };

            const startX = rng.randomInt(1, width - 2);
            const startY = rng.randomInt(1, Math.floor(height / 4));
            const goalY = rng.randomInt(Math.floor(height * 3 / 4), height - 2);
            let goalX = startX < width / 2 ? rng.randomInt(Math.floor(width * 2 / 3), width - 2) : rng.randomInt(1, Math.floor(width / 3));

            const path = generatePath(rng, width, height, startX, startY, goalX, goalY, params.pathTurns);
            const playableArea = new Set();

            for (const point of path) {
                const key = `${point.x},${point.y}`;
                playableArea.add(key);
                for (let dx = -Math.floor(params.pathWidth / 2); dx <= Math.floor(params.pathWidth / 2); dx++) {
                    for (let dy = -Math.floor(params.pathWidth / 2); dy <= Math.floor(params.pathWidth / 2); dy++) {
                        const nx = point.x + dx, ny = point.y + dy;
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            playableArea.add(`${nx},${ny}`);
                        }
                    }
                }
            }

            for (const key of playableArea) {
                const [x, y] = key.split(',').map(Number);
                grid[y][x] = SURFACE.NORMAL;
            }

            grid[startY][startX] = SURFACE.START;
            grid[goalY][goalX] = SURFACE.GOAL;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (grid[y][x] === SURFACE.NORMAL) {
                        const isPathTile = path.some(p => p.x === x && p.y === y);
                        if (isPathTile && rng.random() < 0.8) continue;
                        const roll = rng.random();
                        if (roll < params.empty) grid[y][x] = SURFACE.NONE;
                        else if (roll < params.empty + params.ice) grid[y][x] = SURFACE.ICE;
                        else if (roll < params.empty + params.ice + params.sticky) grid[y][x] = SURFACE.STICKY;
                        else if (roll < params.empty + params.ice + params.sticky + params.acid) grid[y][x] = SURFACE.ACID;
                        else if (roll < params.empty + params.ice + params.sticky + params.acid + params.elevated) grid[y][x] = SURFACE.ELEVATED;
                    }
                }
            }

            // Place coins only on existing solid tiles
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const tileType = grid[y][x];
                    if ((tileType === SURFACE.NORMAL || tileType === SURFACE.ICE || 
                         tileType === SURFACE.STICKY || tileType === SURFACE.ELEVATED) &&
                        rng.random() < params.coins) {
                        const dist = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
                        if (dist > 2) {
                            grid[y][x] = SURFACE.COIN;
                        }
                    }
                }
            }

            if (params.enemies > 0) {
                const potentialEnemySpots = [];
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (grid[y][x] === SURFACE.NORMAL || grid[y][x] === SURFACE.ICE || 
                            grid[y][x] === SURFACE.STICKY || grid[y][x] === SURFACE.ELEVATED) {
                            const dist = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
                            if (dist > 4) potentialEnemySpots.push({ x, y });
                        }
                    }
                }
                for (let i = potentialEnemySpots.length - 1; i > 0; i--) {
                    const j = Math.floor(rng.random() * (i + 1));
                    [potentialEnemySpots[i], potentialEnemySpots[j]] = [potentialEnemySpots[j], potentialEnemySpots[i]];
                }
                for (let i = 0; i < Math.min(params.enemies, potentialEnemySpots.length); i++) {
                    const spot = potentialEnemySpots[i];
                    grid[spot.y][spot.x] = SURFACE.ENEMY;
                }
            }

            ensurePath(grid, path);
            return grid;
        }

        function generatePath(rng, width, height, startX, startY, goalX, goalY, turns) {
            const path = [{ x: startX, y: startY }];
            let currentX = startX, currentY = startY;
            const points = [{ x: startX, y: startY }];

            for (let i = 0; i < turns; i++) {
                const horizontal = rng.randomBool();
                if (horizontal) {
                    const targetX = i === turns - 1 ? goalX : rng.randomInt(1, width - 2);
                    points.push({ x: targetX, y: currentY });
                    currentX = targetX;
                } else {
                    const targetY = i === turns - 1 ? goalY : rng.randomInt(1, height - 2);
                    points.push({ x: currentX, y: targetY });
                    currentY = targetY;
                }
            }

            if (points[points.length - 1].x !== goalX || points[points.length - 1].y !== goalY) {
                points.push({ x: goalX, y: goalY });
            }

            for (let i = 1; i < points.length; i++) {
                const from = points[i - 1], to = points[i];
                const line = getLine(from.x, from.y, to.x, to.y);
                for (let j = 1; j < line.length; j++) path.push(line[j]);
            }
            return path;
        }

        function getLine(x1, y1, x2, y2) {
            const points = [];
            const dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1);
            const sx = (x1 < x2) ? 1 : -1, sy = (y1 < y2) ? 1 : -1;
            let err = dx - dy, x = x1, y = y1;

            while (true) {
                points.push({ x, y });
                if (x === x2 && y === y2) break;
                const e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x += sx; }
                if (e2 < dx) { err += dx; y += sy; }
            }
            return points;
        }

        function ensurePath(grid, path) {
            for (const point of path) {
                if (grid[point.y][point.x] === SURFACE.NONE) {
                    grid[point.y][point.x] = SURFACE.NORMAL;
                }
            }
        }

        function createLevel() {
            levelGroup = new THREE.Group();
            scene.add(levelGroup);
            const levelDefinition = generateProceduralLevel(currentLevel);
            
            const materials = {
                [SURFACE.NORMAL]: new THREE.MeshPhongMaterial({ color: 0x4682B4 }),
                [SURFACE.START]: new THREE.MeshPhongMaterial({ color: 0x32CD32, emissive: 0x001100 }),
                [SURFACE.GOAL]: new THREE.MeshPhongMaterial({ color: 0x32CD32, emissive: 0x001100 }),
                [SURFACE.ICE]: new THREE.MeshPhongMaterial({ color: 0xADD8E6, transparent: true, opacity: 0.8 }),
                [SURFACE.STICKY]: new THREE.MeshPhongMaterial({ color: 0x8B4513 }),
                [SURFACE.ACID]: new THREE.MeshPhongMaterial({ color: 0xFF0000, transparent: true, opacity: 0.8, emissive: 0x330000 }),
                [SURFACE.ELEVATED]: new THREE.MeshPhongMaterial({ color: 0x9370DB }),
                [SURFACE.COIN]: new THREE.MeshPhongMaterial({ color: 0xFFD700, emissive: 0x332200 })
            };

            const levelWidth = levelDefinition[0].length, levelHeight = levelDefinition.length;
            const offsetX = -levelWidth / 2 + 0.5, offsetZ = -levelHeight / 2 + 0.5;
            enemies = [];
            coins = [];

            for (let z = 0; z < levelHeight; z++) {
                for (let x = 0; x < levelWidth; x++) {
                    const tileType = levelDefinition[z][x];
                    if (tileType > 0 && tileType !== SURFACE.ENEMY && tileType !== SURFACE.COIN) {
                        let tileHeight = 0.5, tileY = -tileHeight / 2;
                        if (tileType === SURFACE.ELEVATED) {
                            tileHeight = 0.8;
                            tileY = -tileHeight / 2 + 0.15;
                        }
                        
                        const tile = new THREE.Mesh(new THREE.BoxGeometry(1, tileHeight, 1), materials[tileType] || materials[SURFACE.NORMAL]);
                        tile.position.set(x + offsetX, tileY, z + offsetZ);
                        tile.userData = { type: tileType };
                        tile.castShadow = true;
                        tile.receiveShadow = true;
                        levelGroup.add(tile);

                        if (tileType === SURFACE.START) {
                            marble.position.set(x + offsetX, SETTINGS.marbleRadius, z + offsetZ);
                        }
                        if (tileType === SURFACE.ACID) {
                            tile.userData.animOffset = Math.random() * Math.PI * 2;
                        }
                    }
                    
                    if (tileType === SURFACE.ENEMY && currentLevel >= SETTINGS.enemyStartLevel) {
                        createEnemy(x + offsetX, z + offsetZ);
                    }
                    
                    if (tileType === SURFACE.COIN) {
                        // Create the base tile underneath the coin
                        const baseTile = new THREE.Mesh(new THREE.BoxGeometry(1, 0.5, 1), materials[SURFACE.NORMAL]);
                        baseTile.position.set(x + offsetX, -0.25, z + offsetZ);
                        baseTile.userData = { type: SURFACE.NORMAL };
                        baseTile.castShadow = true;
                        baseTile.receiveShadow = true;
                        levelGroup.add(baseTile);
                        
                        createCoin(x + offsetX, z + offsetZ);
                    }
                }
            }
            
            levelNumber.textContent = currentLevel;
        }

        function createSlinky(segments = 8) {
            const slinkyGroup = new THREE.Group();
            const segmentGeometry = new THREE.TorusGeometry(0.2, 0.05, 8, 16);
            const segmentMaterial = new THREE.MeshPhongMaterial({ color: 0xFF4444, emissive: 0x220000 });
            
            for (let i = 0; i < segments; i++) {
                const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                segment.position.y = i * 0.1;
                segment.castShadow = true;
                slinkyGroup.add(segment);
            }
            
            return slinkyGroup;
        }

        function createEnemy(x, z) {
            const slinky = createSlinky();
            slinky.position.set(x, 0.4, z);
            slinky.userData = {
                direction: new THREE.Vector2(Math.random() - 0.5, Math.random() - 0.5).normalize(),
                timeSinceDirectionChange: 0,
                animationTime: 0
            };
            levelGroup.add(slinky);
            enemies.push(slinky);
        }

        function createCoin(x, z) {
            const coinGeometry = new THREE.CylinderGeometry(0.225, 0.225, 0.075, 16);
            const coinMaterial = new THREE.MeshPhongMaterial({ color: 0xFFD700, emissive: 0x332200 });
            const coin = new THREE.Mesh(coinGeometry, coinMaterial);
            coin.position.set(x, 0.5, z);
            coin.rotation.x = Math.PI / 2; // Make vertical (standing up)
            coin.userData = { type: SURFACE.COIN, collected: false };
            coin.castShadow = true;
            levelGroup.add(coin);
            coins.push(coin);
        }

        function createMarble() {
            marble = new THREE.Mesh(new THREE.SphereGeometry(SETTINGS.marbleRadius, 32, 32), new THREE.MeshPhongMaterial({ color: 0xFFFFFF, specular: 0x111111, shininess: 100 }));
            marble.castShadow = true;
            marble.receiveShadow = true;
            scene.add(marble);
            marbleVelocity = { x: 0, y: 0, z: 0 };
            isJumping = false;
            isFalling = false;
        }

        function startJoystick(x, y, pointerType) {
            if (gameState !== GAME_STATE.PLAYING || joystickActive) return;
            currentPointerType = pointerType;
            joystickActive = true;
            joystickOrigin.x = x;
            joystickOrigin.y = y;
            joystickVector.x = 0;
            joystickVector.y = 0;
            joystickBase.style.left = `${x}px`;
            joystickBase.style.top = `${y}px`;
            joystickBase.style.display = 'block';
            updateJoystickPosition(0, 0);
        }

        function moveJoystick(x, y, pointerType) {
            if (!joystickActive || currentPointerType !== pointerType) return;
            const dx = x - joystickOrigin.x, dy = y - joystickOrigin.y;
            const dist = Math.sqrt(dx * dx + dy * dy), maxDist = 50;
            const clampedDist = Math.min(maxDist, dist), angle = Math.atan2(dy, dx);
            joystickVector.x = Math.cos(angle) * (clampedDist / maxDist);
            joystickVector.y = Math.sin(angle) * (clampedDist / maxDist);
            updateJoystickPosition(joystickVector.x * maxDist, joystickVector.y * maxDist);
        }

        function endJoystick(pointerType) {
            if (!joystickActive || currentPointerType !== pointerType) return;
            joystickActive = false;
            currentPointerType = null;
            joystickVector.x = 0;
            joystickVector.y = 0;
            joystickBase.style.display = 'none';
        }

        function resetJoystick() {
            joystickActive = false;
            currentPointerType = null;
            joystickVector.x = 0;
            joystickVector.y = 0;
            joystickBase.style.display = 'none';
        }

        function updateJoystickPosition(dx, dy) {
            joystickKnob.style.left = `${60 + dx}px`;
            joystickKnob.style.top = `${60 + dy}px`;
        }

        function setupEventListeners() {
            const canvas = document.getElementById('game-canvas');
            
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    startJoystick(touch.clientX, touch.clientY, 'touch');
                }
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    moveJoystick(touch.clientX, touch.clientY, 'touch');
                }
            }, { passive: false });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                endJoystick('touch');
            }, { passive: false });

            canvas.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startJoystick(e.clientX, e.clientY, 'mouse');
            });

            canvas.addEventListener('mousemove', (e) => {
                moveJoystick(e.clientX, e.clientY, 'mouse');
            });

            canvas.addEventListener('mouseup', (e) => {
                e.preventDefault();
                endJoystick('mouse');
            });

            window.addEventListener('resize', onWindowResize);
            startButton.addEventListener('click', startGame);
            restartLevelButton.addEventListener('click', restartLevel);
            mainMenuButton.addEventListener('click', goToMainMenu);
            nextLevelButton.addEventListener('click', nextLevel);
            menuButton.addEventListener('click', goToMainMenu);
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const viewSize = window.innerHeight > window.innerWidth ? 10 : 5;
            camera.left = -viewSize * aspect;
            camera.right = viewSize * aspect;
            camera.top = viewSize;
            camera.bottom = -viewSize;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function startGame() {
            gameState = GAME_STATE.PLAYING;
            currentLevel = 1;
            score = 0;
            startScreen.style.display = 'none';
            startTime = Date.now();
            timeLeft = SETTINGS.timeLimit;
            
            if (levelGroup) scene.remove(levelGroup);
            if (marble) scene.remove(marble);
            
            createMarble();
            createLevel();
            resetJoystick();
            updateScore();
        }

        function nextLevel() {
            levelCompleteScreen.style.display = 'none';
            currentLevel++;
            gameState = GAME_STATE.PLAYING;
            
            if (levelGroup) scene.remove(levelGroup);
            
            marbleVelocity = { x: 0, y: 0, z: 0 };
            isJumping = false;
            isFalling = false;
            
            if (marble) {
                marble.visible = true;
            } else {
                createMarble();
            }
            
            createLevel();
            timeLeft += 30;
            startTime = Date.now() - (SETTINGS.timeLimit - timeLeft) * 1000;
            resetJoystick();
        }

        function restartLevel() {
            gameOverScreen.style.display = 'none';
            gameState = GAME_STATE.PLAYING;
            
            if (levelGroup) scene.remove(levelGroup);
            if (marble) scene.remove(marble);
            
            createMarble();
            createLevel();
            timeLeft = SETTINGS.timeLimit + 30 * (currentLevel - 1);
            startTime = Date.now();
            resetJoystick();
        }

        function goToMainMenu() {
            gameOverScreen.style.display = 'none';
            levelCompleteScreen.style.display = 'none';
            startScreen.style.display = 'flex';
            gameState = GAME_STATE.MENU;
            
            if (levelGroup) scene.remove(levelGroup);
            if (marble) scene.remove(marble);
        }

        function gameOver() {
            gameState = GAME_STATE.GAME_OVER;
            resetJoystick();
            
            // Reset to start screen after a delay
            setTimeout(() => {
                startScreen.style.display = 'flex';
                gameState = GAME_STATE.MENU;
            }, 2000);
        }

        function updateScore() {
            scoreValue.textContent = score;
        }

        function addScore(points) {
            score += points;
            updateScore();
        }

        function updateTimer() {
            if (gameState === GAME_STATE.PLAYING) {
                const currentTime = Date.now();
                const elapsedSeconds = Math.floor((currentTime - startTime) / 1000);
                timeLeft = Math.max(0, SETTINGS.timeLimit + 30 * (currentLevel - 1) - elapsedSeconds);
                timeValue.textContent = timeLeft;
                
                // Visual warning when time is low
                if (timeLeft <= 10) {
                    timeValue.style.color = '#ff4444';
                    timeValue.style.fontWeight = 'bold';
                } else if (timeLeft <= 30) {
                    timeValue.style.color = '#ffaa00';
                } else {
                    timeValue.style.color = 'white';
                    timeValue.style.fontWeight = 'normal';
                }
                
                if (timeLeft <= 0) disintegrateMarble();
            }
        }

        function getMarbleSurface() {
            const raycaster = new THREE.Raycaster(marble.position.clone(), new THREE.Vector3(0, -1, 0));
            const intersects = raycaster.intersectObjects(levelGroup.children);
            if (intersects.length > 0 && intersects[0].distance < SETTINGS.marbleRadius + 0.1) {
                return intersects[0].object.userData.type || SURFACE.NORMAL;
            }
            return SURFACE.NONE;
        }

        function isMarbleAtGoal() {
            return getMarbleSurface() === SURFACE.GOAL;
        }

        function isMarbleTouchingEnemy() {
            for (const enemy of enemies) {
                const distance = marble.position.distanceTo(enemy.position);
                if (distance < SETTINGS.marbleRadius + 0.6) return true;
            }
            return false;
        }

        function checkCoinCollisions() {
            for (const coin of coins) {
                if (!coin.userData.collected) {
                    const distance = marble.position.distanceTo(coin.position);
                    if (distance < SETTINGS.marbleRadius + 0.3) {
                        coin.userData.collected = true;
                        coin.visible = false;
                        addScore(100);
                    }
                }
            }
        }

        function updateEnemies() {
            for (const enemy of enemies) {
                enemy.userData.animationTime += 0.02;
                
                // Animate slinky segments
                enemy.children.forEach((segment, index) => {
                    segment.rotation.y = enemy.userData.animationTime + index * 0.3;
                    segment.position.y = 0.1 + index * 0.08 + Math.sin(enemy.userData.animationTime * 2 + index * 0.5) * 0.02;
                });
                
                // Move enemy
                enemy.position.x += enemy.userData.direction.x * enemySpeed;
                enemy.position.z += enemy.userData.direction.y * enemySpeed;
                enemy.userData.timeSinceDirectionChange += 1 / 60;
                
                // Check for direction change
                const raycaster = new THREE.Raycaster(
                    enemy.position.clone(), 
                    new THREE.Vector3(enemy.userData.direction.x, 0, enemy.userData.direction.y).normalize()
                );
                const intersects = raycaster.intersectObjects(levelGroup.children);
                
                if (intersects.length > 0 && intersects[0].distance < 0.8 || enemy.userData.timeSinceDirectionChange > 4) {
                    enemy.userData.direction = new THREE.Vector2(Math.random() - 0.5, Math.random() - 0.5).normalize();
                    enemy.userData.timeSinceDirectionChange = 0;
                }
            }
        }

        function updateCoins() {
            const time = Date.now() * 0.005;
            for (const coin of coins) {
                if (!coin.userData.collected) {
                    coin.rotation.z = time; // Spin around Z-axis for vertical coin spinning
                    coin.position.y = 0.5 + Math.sin(time * 1.5) * 0.1;
                }
            }
        }

        function updateMarblePhysics() {
            if (gameState === GAME_STATE.PLAYING) {
                const surfaceType = getMarbleSurface();
                let frictionFactor = 0.98, speedMultiplier = 1.0;
                
                if (surfaceType === SURFACE.ICE) {
                    frictionFactor = 0.995;
                    speedMultiplier = SETTINGS.iceMultiplier;
                } else if (surfaceType === SURFACE.STICKY) {
                    frictionFactor = 0.94;
                    speedMultiplier = SETTINGS.stickyMultiplier;
                } else if (surfaceType === SURFACE.ACID) {
                    disintegrateMarble();
                    return;
                }
                
                if (surfaceType === SURFACE.ELEVATED && !isJumping && !isFalling) {
                    marble.position.y = SETTINGS.marbleRadius + 0.15;
                } else if (surfaceType !== SURFACE.NONE && !isJumping && !isFalling) {
                    marble.position.y = SETTINGS.marbleRadius;
                }

                if (surfaceType !== SURFACE.NONE && !isJumping && !isFalling) {
                    const accel = 0.003;
                    const cameraRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    const cameraDown = new THREE.Vector3(0, 0, 1).applyQuaternion(camera.quaternion);

                    marbleVelocity.x += (joystickVector.x * cameraRight.x + joystickVector.y * cameraDown.x) * accel;
                    marbleVelocity.z += (joystickVector.x * cameraRight.z + joystickVector.y * cameraDown.z) * accel;

                    marble.position.x += marbleVelocity.x * speedMultiplier;
                    marble.position.z += marbleVelocity.z * speedMultiplier;

                    marbleVelocity.x *= frictionFactor;
                    marbleVelocity.z *= frictionFactor;
                    
                    if (Math.abs(marbleVelocity.x) < 0.001) marbleVelocity.x = 0;
                    if (Math.abs(marbleVelocity.z) < 0.001) marbleVelocity.z = 0;
                }

                if (surfaceType === SURFACE.NONE || isJumping) {
                    marbleVelocity.y -= SETTINGS.gravity;
                    isFalling = true;
                } else {
                    marbleVelocity.y = 0;
                    isFalling = false;
                }

                marble.position.y += marbleVelocity.y;

                // Fixed: Disintegrate marble when falling in a hole
                if (marble.position.y < -2) {
                    disintegrateMarble();
                    return;
                }

                if (isMarbleAtGoal()) {
                    addScore(currentLevel * 50);
                    showLevelComplete();
                }

                if (isMarbleTouchingEnemy()) {
                    disintegrateMarble();
                    return;
                }

                checkCoinCollisions();
            }
        }

        function showLevelComplete() {
            gameState = GAME_STATE.WIN;
            resetJoystick();
            completedLevel.textContent = currentLevel;
            levelScore.textContent = score;
            levelCompleteScreen.style.display = 'flex';
        }

        function disintegrateMarble() {
            gameState = GAME_STATE.GAME_OVER;
            
            const particleCount = 20;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 8, 8), 
                    new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.8 })
                );
                particle.position.copy(marble.position);
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.2, 
                        Math.random() * 0.1, 
                        (Math.random() - 0.5) * 0.2
                    ),
                    life: 1.0,
                    decay: 0.02
                };
                scene.add(particle);
                particles.push(particle);
            }
            
            marble.visible = false;
            
            const animateParticles = () => {
                let aliveParticles = 0;
                
                particles.forEach(particle => {
                    if (particle.userData.life > 0) {
                        particle.position.add(particle.userData.velocity);
                        particle.userData.velocity.y -= 0.005;
                        particle.userData.life -= particle.userData.decay;
                        particle.material.opacity = particle.userData.life;
                        aliveParticles++;
                    } else {
                        scene.remove(particle);
                    }
                });
                
                if (aliveParticles > 0 && gameState === GAME_STATE.GAME_OVER) {
                    requestAnimationFrame(animateParticles);
                } else {
                    particles.forEach(particle => scene.remove(particle));
                    if (gameState === GAME_STATE.GAME_OVER) {
                        resetJoystick();
                        setTimeout(() => {
                            finalScore.textContent = score;
                            gameOverScreen.style.display = 'flex';
                        }, 500);
                    }
                }
            };
            
            animateParticles();
        }

        function updateAcidAnimation() {
            if (gameState === GAME_STATE.PLAYING) {
                levelGroup.children.forEach(child => {
                    if (child.userData && child.userData.type === SURFACE.ACID) {
                        const time = Date.now() * 0.001;
                        const offset = child.userData.animOffset || 0;
                        child.position.y = -0.25 + Math.sin(time + offset) * 0.05;
                        
                        // Animate acid glow
                        const glowIntensity = 0.3 + Math.sin(time * 2 + offset) * 0.2;
                        child.material.emissive.setRGB(glowIntensity, 0, 0);
                    }
                });
            }
        }

        function updateCamera() {
            if (marble && gameState === GAME_STATE.PLAYING) {
                cameraTargetPosition.copy(marble.position);
                cameraTargetPosition.y = 0;
                camera.position.x += (cameraTargetPosition.x - camera.position.x + SETTINGS.cameraDistance) * cameraSmoothing;
                camera.position.z += (cameraTargetPosition.z - camera.position.z + SETTINGS.cameraDistance) * cameraSmoothing;
                camera.position.y = SETTINGS.cameraDistance;
                camera.lookAt(marble.position);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (gameState === GAME_STATE.PLAYING) {
                updateMarblePhysics();
                updateEnemies();
                updateCoins();
                updateAcidAnimation();
                updateTimer();
                updateCamera();
            }
            
            if (marble) {
                marble.rotation.x += marbleVelocity.z * 2;
                marble.rotation.z -= marbleVelocity.x * 2;
            }
            
            renderer.render(scene, camera);
        }

        window.addEventListener('load', init);
        if (document.readyState === 'complete') init();
    </script>
</body>
</html>