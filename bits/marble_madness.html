<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marble Madness</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            touch-action: none;
        }
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 2;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            pointer-events: none;
        }
        #timer {
            margin-bottom: 5px;
        }
        #start-screen, #end-screen, #level-complete-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            z-index: 3;
        }
        #end-screen, #level-complete-screen {
            display: none;
        }
        h1, h2 {
            margin-bottom: 30px;
            font-size: 36px;
            text-align: center;
        }
        button {
            padding: 15px 30px;
            font-size: 18px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            touch-action: manipulation;
        }
        button:hover {
            background-color: #45a049;
        }
        #status {
            font-size: 24px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 4;
        }
        #joystick-base {
            position: absolute;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: none;
            z-index: 5;
            transform: translate(-50%, -50%);
            touch-action: none;
            pointer-events: none;
        }
        #joystick-knob {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            position: absolute;
            top: 25px;
            left: 25px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="ui-container">
            <div id="timer">Time: <span id="time-value">60</span></div>
            <div id="joystick-base">
                <div id="joystick-knob"></div>
            </div>
        </div>
        <div id="start-screen">
            <h1>Marble Madness</h1>
            <button id="start-button">Start Game</button>
        </div>
        <div id="end-screen">
            <h2 id="end-message"></h2>
            <button id="restart-button">Play Again</button>
        </div>
        <div id="level-complete-screen">
            <h2 id="level-complete-message">Level Completed!</h2>
            <button id="continue-button">Continue</button>
        </div>
        <div id="status"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const GAME_STATE = { MENU: 0, PLAYING: 1, GAME_OVER: 2, WIN: 3 };
        const SETTINGS = { marbleRadius: 0.5, cameraDistance: 15, timeLimit: 60, gravity: 0.015, iceMultiplier: 1.5, stickyMultiplier: 0.5, enemyStartLevel: 3, maxLevels: 5 };
        const SURFACE = { NONE: 0, NORMAL: 1, START: 2, GOAL: 3, ICE: 4, STICKY: 5, ENEMY: 6, ACID: 7, ELEVATED: 8 };

        let renderer, scene, camera, marble, levelGroup, startTime, timeLeft;
        let gameState = GAME_STATE.MENU;
        let marbleVelocity = { x: 0, z: 0, y: 0 };
        let enemies = [], isJumping = false, isFalling = false, currentLevel = 1, enemySpeed = 0.05;
        let cameraTargetPosition = new THREE.Vector3(), cameraSmoothing = 0.1;
        let joystickActive = false, joystickOrigin = { x: 0, y: 0 }, joystickVector = { x: 0, y: 0 }, currentPointerType = null;

        const joystickBase = document.getElementById('joystick-base');
        const joystickKnob = document.getElementById('joystick-knob');
        const startScreen = document.getElementById('start-screen');
        const endScreen = document.getElementById('end-screen');
        const levelCompleteScreen = document.getElementById('level-complete-screen');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const continueButton = document.getElementById('continue-button');
        const endMessage = document.getElementById('end-message');
        const levelCompleteMessage = document.getElementById('level-complete-message');
        const timeValue = document.getElementById('time-value');
        const statusEl = document.getElementById('status');

        function init() {
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000);

            scene = new THREE.Scene();
            const aspect = window.innerWidth / window.innerHeight;
            const viewSize = window.innerHeight > window.innerWidth ? 10 : 5;
            camera = new THREE.OrthographicCamera(-viewSize * aspect, viewSize * aspect, viewSize, -viewSize, 0.1, 1000);
            camera.position.set(SETTINGS.cameraDistance, SETTINGS.cameraDistance, SETTINGS.cameraDistance);
            camera.lookAt(0, 0, 0);

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            scene.add(directionalLight);

            setupEventListeners();
            animate();
        }

        class SeededRandom {
            constructor(seed) { this.seed = seed; }
            random() { const x = Math.sin(this.seed++) * 10000; return x - Math.floor(x); }
            randomInt(min, max) { return Math.floor(this.random() * (max - min + 1)) + min; }
            randomBool(probability = 0.5) { return this.random() < probability; }
        }

        function generateProceduralLevel(level) {
            const rng = new SeededRandom(level * 1000 + Math.floor(Math.random() * 1000));
            const width = 10 + Math.min(6, Math.floor(level * 0.5));
            const height = 15 + Math.min(8, Math.floor(level * 0.7));
            let grid = Array(height).fill().map(() => Array(width).fill(SURFACE.NONE));

            const params = {
                ice: Math.min(0.02 + (level - 1) * 0.03, 0.20),
                sticky: Math.min(0.02 + (level - 1) * 0.02, 0.15),
                acid: level > 1 ? Math.min(0.01 + (level - 2) * 0.02, 0.12) : 0,
                elevated: Math.min(0.02 + (level - 1) * 0.03, 0.18),
                empty: Math.min(0.1 + (level - 1) * 0.02, 0.25),
                enemies: level >= SETTINGS.enemyStartLevel ? Math.min(level - SETTINGS.enemyStartLevel + 1, 5) : 0,
                pathTurns: 3 + Math.min(level, 7),
                pathWidth: Math.max(2, 4 - Math.floor(level / 2))
            };

            const startX = rng.randomInt(1, width - 2);
            const startY = rng.randomInt(1, Math.floor(height / 4));
            const goalY = rng.randomInt(Math.floor(height * 3 / 4), height - 2);
            let goalX = startX < width / 2 ? rng.randomInt(Math.floor(width * 2 / 3), width - 2) : rng.randomInt(1, Math.floor(width / 3));

            const path = generatePath(rng, width, height, startX, startY, goalX, goalY, params.pathTurns);
            const playableArea = new Set();

            for (const point of path) {
                const key = `${point.x},${point.y}`;
                playableArea.add(key);
                for (let dx = -Math.floor(params.pathWidth / 2); dx <= Math.floor(params.pathWidth / 2); dx++) {
                    for (let dy = -Math.floor(params.pathWidth / 2); dy <= Math.floor(params.pathWidth / 2); dy++) {
                        const nx = point.x + dx, ny = point.y + dy;
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            playableArea.add(`${nx},${ny}`);
                        }
                    }
                }
            }

            for (const key of playableArea) {
                const [x, y] = key.split(',').map(Number);
                grid[y][x] = SURFACE.NORMAL;
            }

            grid[startY][startX] = SURFACE.START;
            grid[goalY][goalX] = SURFACE.GOAL;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (grid[y][x] === SURFACE.NORMAL) {
                        const isPathTile = path.some(p => p.x === x && p.y === y);
                        if (isPathTile && rng.random() < 0.8) continue;
                        const roll = rng.random();
                        if (roll < params.empty) grid[y][x] = SURFACE.NONE;
                        else if (roll < params.empty + params.ice) grid[y][x] = SURFACE.ICE;
                        else if (roll < params.empty + params.ice + params.sticky) grid[y][x] = SURFACE.STICKY;
                        else if (roll < params.empty + params.ice + params.sticky + params.acid) grid[y][x] = SURFACE.ACID;
                        else if (roll < params.empty + params.ice + params.sticky + params.acid + params.elevated) grid[y][x] = SURFACE.ELEVATED;
                    }
                }
            }

            if (params.enemies > 0) {
                const potentialEnemySpots = [];
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (grid[y][x] === SURFACE.NORMAL) {
                            const dist = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
                            if (dist > 4) potentialEnemySpots.push({ x, y });
                        }
                    }
                }
                for (let i = potentialEnemySpots.length - 1; i > 0; i--) {
                    const j = Math.floor(rng.random() * (i + 1));
                    [potentialEnemySpots[i], potentialEnemySpots[j]] = [potentialEnemySpots[j], potentialEnemySpots[i]];
                }
                for (let i = 0; i < Math.min(params.enemies, potentialEnemySpots.length); i++) {
                    const spot = potentialEnemySpots[i];
                    grid[spot.y][spot.x] = SURFACE.ENEMY;
                }
            }

            ensurePath(grid, path);
            return grid;
        }

        function generatePath(rng, width, height, startX, startY, goalX, goalY, turns) {
            const path = [{ x: startX, y: startY }];
            let currentX = startX, currentY = startY;
            const points = [{ x: startX, y: startY }];

            for (let i = 0; i < turns; i++) {
                const horizontal = rng.randomBool();
                if (horizontal) {
                    const targetX = i === turns - 1 ? goalX : rng.randomInt(1, width - 2);
                    points.push({ x: targetX, y: currentY });
                    currentX = targetX;
                } else {
                    const targetY = i === turns - 1 ? goalY : rng.randomInt(1, height - 2);
                    points.push({ x: currentX, y: targetY });
                    currentY = targetY;
                }
            }

            if (points[points.length - 1].x !== goalX || points[points.length - 1].y !== goalY) {
                points.push({ x: goalX, y: goalY });
            }

            for (let i = 1; i < points.length; i++) {
                const from = points[i - 1], to = points[i];
                const line = getLine(from.x, from.y, to.x, to.y);
                for (let j = 1; j < line.length; j++) path.push(line[j]);
            }
            return path;
        }

        function getLine(x1, y1, x2, y2) {
            const points = [];
            const dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1);
            const sx = (x1 < x2) ? 1 : -1, sy = (y1 < y2) ? 1 : -1;
            let err = dx - dy, x = x1, y = y1;

            while (true) {
                points.push({ x, y });
                if (x === x2 && y === y2) break;
                const e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x += sx; }
                if (e2 < dx) { err += dx; y += sy; }
            }
            return points;
        }

        function ensurePath(grid, path) {
            for (const point of path) {
                if (grid[point.y][point.x] === SURFACE.NONE) {
                    grid[point.y][point.x] = SURFACE.NORMAL;
                }
            }
        }

        function createLevel() {
            levelGroup = new THREE.Group();
            scene.add(levelGroup);
            const levelDefinition = generateProceduralLevel(currentLevel);
            
            const materials = {
                [SURFACE.NORMAL]: new THREE.MeshPhongMaterial({ color: 0x4682B4 }),
                [SURFACE.START]: new THREE.MeshPhongMaterial({ color: 0x32CD32 }),
                [SURFACE.GOAL]: new THREE.MeshPhongMaterial({ color: 0x32CD32 }),
                [SURFACE.ICE]: new THREE.MeshPhongMaterial({ color: 0xADD8E6 }),
                [SURFACE.STICKY]: new THREE.MeshPhongMaterial({ color: 0x8B4513 }),
                [SURFACE.ACID]: new THREE.MeshPhongMaterial({ color: 0xFF0000, transparent: true, opacity: 0.8 }),
                [SURFACE.ELEVATED]: new THREE.MeshPhongMaterial({ color: 0x9370DB })
            };

            const levelWidth = levelDefinition[0].length, levelHeight = levelDefinition.length;
            const offsetX = -levelWidth / 2 + 0.5, offsetZ = -levelHeight / 2 + 0.5;
            enemies = [];

            for (let z = 0; z < levelHeight; z++) {
                for (let x = 0; x < levelWidth; x++) {
                    const tileType = levelDefinition[z][x];
                    if (tileType > 0) {
                        let tileHeight = 0.5, tileY = -tileHeight / 2;
                        if (tileType === SURFACE.ELEVATED) {
                            tileHeight = 0.8;
                            tileY = -tileHeight / 2 + 0.15;
                        }
                        
                        const tile = new THREE.Mesh(new THREE.BoxGeometry(1, tileHeight, 1), materials[tileType] || materials[SURFACE.NORMAL]);
                        tile.position.set(x + offsetX, tileY, z + offsetZ);
                        tile.userData = { type: tileType };
                        levelGroup.add(tile);

                        if (tileType === SURFACE.START) {
                            marble.position.set(x + offsetX, SETTINGS.marbleRadius, z + offsetZ);
                        }
                        if (tileType === SURFACE.ENEMY && currentLevel >= SETTINGS.enemyStartLevel) {
                            createEnemy(x + offsetX, z + offsetZ);
                        }
                        if (tileType === SURFACE.ACID) {
                            tile.userData.animOffset = Math.random() * Math.PI * 2;
                        }
                    }
                }
            }
        }

        function createEnemy(x, z) {
            const enemy = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), new THREE.MeshPhongMaterial({ color: 0xFF0000 }));
            enemy.position.set(x, 0.4, z);
            enemy.userData = {
                direction: new THREE.Vector2(Math.random() - 0.5, Math.random() - 0.5).normalize(),
                timeSinceDirectionChange: 0
            };
            levelGroup.add(enemy);
            enemies.push(enemy);
        }

        function createMarble() {
            marble = new THREE.Mesh(new THREE.SphereGeometry(SETTINGS.marbleRadius, 32, 32), new THREE.MeshPhongMaterial({ color: 0xFFFFFF, specular: 0x111111, shininess: 100 }));
            scene.add(marble);
            marbleVelocity = { x: 0, y: 0, z: 0 };
            isJumping = false;
            isFalling = false;
        }

        function startJoystick(x, y, pointerType) {
            if (gameState !== GAME_STATE.PLAYING || joystickActive) return;
            currentPointerType = pointerType;
            joystickActive = true;
            joystickOrigin.x = x;
            joystickOrigin.y = y;
            joystickVector.x = 0;
            joystickVector.y = 0;
            joystickBase.style.left = `${x}px`;
            joystickBase.style.top = `${y}px`;
            joystickBase.style.display = 'block';
            updateJoystickPosition(0, 0);
        }

        function moveJoystick(x, y, pointerType) {
            if (!joystickActive || currentPointerType !== pointerType) return;
            const dx = x - joystickOrigin.x, dy = y - joystickOrigin.y;
            const dist = Math.sqrt(dx * dx + dy * dy), maxDist = 40;
            const clampedDist = Math.min(maxDist, dist), angle = Math.atan2(dy, dx);
            joystickVector.x = Math.cos(angle) * (clampedDist / maxDist);
            joystickVector.y = Math.sin(angle) * (clampedDist / maxDist);
            updateJoystickPosition(joystickVector.x * maxDist, joystickVector.y * maxDist);
        }

        function endJoystick(pointerType) {
            if (!joystickActive || currentPointerType !== pointerType) return;
            joystickActive = false;
            currentPointerType = null;
            joystickVector.x = 0;
            joystickVector.y = 0;
            joystickBase.style.display = 'none';
        }

        function resetJoystick() {
            joystickActive = false;
            currentPointerType = null;
            joystickVector.x = 0;
            joystickVector.y = 0;
            joystickBase.style.display = 'none';
        }

        function updateJoystickPosition(dx, dy) {
            joystickKnob.style.left = `${50 + dx}px`;
            joystickKnob.style.top = `${50 + dy}px`;
        }

        function setupEventListeners() {
            const canvas = document.getElementById('game-canvas');
            
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    startJoystick(touch.clientX, touch.clientY, 'touch');
                }
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    moveJoystick(touch.clientX, touch.clientY, 'touch');
                }
            }, { passive: false });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                endJoystick('touch');
            }, { passive: false });

            canvas.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startJoystick(e.clientX, e.clientY, 'mouse');
            });

            canvas.addEventListener('mousemove', (e) => {
                moveJoystick(e.clientX, e.clientY, 'mouse');
            });

            canvas.addEventListener('mouseup', (e) => {
                e.preventDefault();
                endJoystick('mouse');
            });

            window.addEventListener('resize', onWindowResize);
            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', restartCurrentLevel);
            continueButton.addEventListener('click', proceedToNextLevel);
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const viewSize = window.innerHeight > window.innerWidth ? 10 : 5;
            camera.left = -viewSize * aspect;
            camera.right = viewSize * aspect;
            camera.top = viewSize;
            camera.bottom = -viewSize;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function startGame() {
            gameState = GAME_STATE.PLAYING;
            currentLevel = 1;
            startScreen.style.display = 'none';
            endScreen.style.display = 'none';
            levelCompleteScreen.style.display = 'none';
            startTime = Date.now();
            timeLeft = SETTINGS.timeLimit;
            
            if (levelGroup) scene.remove(levelGroup);
            if (marble) scene.remove(marble);
            
            createMarble();
            createLevel();
            resetJoystick();
            showStatus('Level ' + currentLevel + ' - Go!');
        }

        function restartCurrentLevel() {
            gameState = GAME_STATE.PLAYING;
            endScreen.style.display = 'none';
            levelCompleteScreen.style.display = 'none';
            
            if (levelGroup) scene.remove(levelGroup);
            marbleVelocity = { x: 0, y: 0, z: 0 };
            isJumping = false;
            isFalling = false;
            
            if (marble) {
                marble.visible = true;
                scene.add(marble);
            } else {
                createMarble();
            }
            
            createLevel();
            resetJoystick();
            showStatus('Try again!');
        }

        function showLevelComplete() {
            gameState = GAME_STATE.MENU;
            resetJoystick();
            levelCompleteMessage.textContent = `Level ${currentLevel} Completed!`;
            levelCompleteScreen.style.display = 'flex';
        }

        function proceedToNextLevel() {
            levelCompleteScreen.style.display = 'none';
            nextLevel();
        }

        function nextLevel() {
            currentLevel++;
            if (currentLevel > SETTINGS.maxLevels) {
                endGame(true);
                return;
            }
            
            gameState = GAME_STATE.PLAYING;
            
            if (levelGroup) scene.remove(levelGroup);
            
            marbleVelocity = { x: 0, y: 0, z: 0 };
            isJumping = false;
            isFalling = false;
            
            if (marble) {
                marble.visible = true;
            } else {
                createMarble();
            }
            
            createLevel();
            timeLeft += 30;
            startTime = Date.now() - (SETTINGS.timeLimit - timeLeft) * 1000;
            resetJoystick();
            showStatus('Level ' + currentLevel + ' - Go!');
        }

        function endGame(isVictory) {
            gameState = isVictory ? GAME_STATE.WIN : GAME_STATE.GAME_OVER;
            resetJoystick();
            endScreen.style.display = 'flex';
            endMessage.textContent = isVictory ? 'Victory!' : 'Try Again!';
        }

        function updateTimer() {
            if (gameState === GAME_STATE.PLAYING) {
                const currentTime = Date.now();
                const elapsedSeconds = Math.floor((currentTime - startTime) / 1000);
                timeLeft = Math.max(0, SETTINGS.timeLimit + 30 * (currentLevel - 1) - elapsedSeconds);
                timeValue.textContent = timeLeft;
                if (timeLeft <= 0) endGame(false);
            }
        }

        function showStatus(message) {
            statusEl.textContent = message;
            statusEl.style.opacity = 1;
            setTimeout(() => { statusEl.style.opacity = 0; }, 2000);
        }

        function getMarbleSurface() {
            const raycaster = new THREE.Raycaster(marble.position.clone(), new THREE.Vector3(0, -1, 0));
            const intersects = raycaster.intersectObjects(levelGroup.children);
            if (intersects.length > 0 && intersects[0].distance < SETTINGS.marbleRadius + 0.1) {
                return intersects[0].object.userData.type || SURFACE.NORMAL;
            }
            return SURFACE.NONE;
        }

        function isMarbleAtGoal() {
            return getMarbleSurface() === SURFACE.GOAL;
        }

        function isMarbleTouchingEnemy() {
            for (const enemy of enemies) {
                const distance = marble.position.distanceTo(enemy.position);
                if (distance < SETTINGS.marbleRadius + 0.4) return true;
            }
            return false;
        }

        function updateEnemies() {
            for (const enemy of enemies) {
                enemy.position.x += enemy.userData.direction.x * enemySpeed;
                enemy.position.z += enemy.userData.direction.y * enemySpeed;
                enemy.userData.timeSinceDirectionChange += 1 / 60;
                
                const raycaster = new THREE.Raycaster(enemy.position.clone(), new THREE.Vector3(enemy.userData.direction.x, 0, enemy.userData.direction.y).normalize());
                const intersects = raycaster.intersectObjects(levelGroup.children);
                
                if (intersects.length > 0 && intersects[0].distance < 0.5 || enemy.userData.timeSinceDirectionChange > 3) {
                    enemy.userData.direction = new THREE.Vector2(Math.random() - 0.5, Math.random() - 0.5).normalize();
                    enemy.userData.timeSinceDirectionChange = 0;
                }
            }
        }

        function updateMarblePhysics() {
            if (gameState === GAME_STATE.PLAYING) {
                const surfaceType = getMarbleSurface();
                let frictionFactor = 0.98, speedMultiplier = 1.0;
                
                if (surfaceType === SURFACE.ICE) {
                    frictionFactor = 0.995;
                    speedMultiplier = SETTINGS.iceMultiplier;
                } else if (surfaceType === SURFACE.STICKY) {
                    frictionFactor = 0.94;
                    speedMultiplier = SETTINGS.stickyMultiplier;
                } else if (surfaceType === SURFACE.ACID) {
                    disintegrateMarble();
                    return;
                }
                
                if (surfaceType === SURFACE.ELEVATED && !isJumping && !isFalling) {
                    marble.position.y = SETTINGS.marbleRadius + 0.15;
                } else if (surfaceType !== SURFACE.NONE && !isJumping && !isFalling) {
                    marble.position.y = SETTINGS.marbleRadius;
                }

                if (surfaceType !== SURFACE.NONE && !isJumping && !isFalling) {
                    const accel = 0.003;
                    const cameraRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    const cameraDown = new THREE.Vector3(0, 0, 1).applyQuaternion(camera.quaternion);

                    marbleVelocity.x += (joystickVector.x * cameraRight.x + joystickVector.y * cameraDown.x) * accel;
                    marbleVelocity.z += (joystickVector.x * cameraRight.z + joystickVector.y * cameraDown.z) * accel;

                    marble.position.x += marbleVelocity.x * speedMultiplier;
                    marble.position.z += marbleVelocity.z * speedMultiplier;

                    marbleVelocity.x *= frictionFactor;
                    marbleVelocity.z *= frictionFactor;
                    
                    if (Math.abs(marbleVelocity.x) < 0.001) marbleVelocity.x = 0;
                    if (Math.abs(marbleVelocity.z) < 0.001) marbleVelocity.z = 0;
                }

                if (surfaceType === SURFACE.NONE || isJumping) {
                    marbleVelocity.y -= SETTINGS.gravity;
                    isFalling = true;
                } else {
                    marbleVelocity.y = 0;
                    isFalling = false;
                }

                marble.position.y += marbleVelocity.y;

                if (marble.position.y < -5) {
                    showStatus('Fell off the level!');
                    endGame(false);
                    return;
                }

                if (isMarbleAtGoal()) {
                    showLevelComplete();
                }

                if (isMarbleTouchingEnemy()) {
                    showStatus('Hit by an enemy!');
                    endGame(false);
                }
            }
        }

        function disintegrateMarble() {
            showStatus('Melted in acid!');
            gameState = GAME_STATE.GAME_OVER;
            
            const particleCount = 20;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.8 }));
                particle.position.copy(marble.position);
                particle.userData = {
                    velocity: new THREE.Vector3((Math.random() - 0.5) * 0.2, Math.random() * 0.1, (Math.random() - 0.5) * 0.2),
                    life: 1.0,
                    decay: 0.02
                };
                scene.add(particle);
                particles.push(particle);
            }
            
            marble.visible = false;
            
            const animateParticles = () => {
                let aliveParticles = 0;
                
                particles.forEach(particle => {
                    if (particle.userData.life > 0) {
                        particle.position.add(particle.userData.velocity);
                        particle.userData.velocity.y -= 0.005;
                        particle.userData.life -= particle.userData.decay;
                        particle.material.opacity = particle.userData.life;
                        aliveParticles++;
                    } else {
                        scene.remove(particle);
                    }
                });
                
                if (aliveParticles > 0 && gameState === GAME_STATE.GAME_OVER) {
                    requestAnimationFrame(animateParticles);
                } else {
                    particles.forEach(particle => scene.remove(particle));
                    if (gameState === GAME_STATE.GAME_OVER) {
                        endScreen.style.display = 'flex';
                        endMessage.textContent = 'Try Again!';
                        resetJoystick();
                    }
                }
            };
            
            animateParticles();
        }

        function updateAcidAnimation() {
            if (gameState === GAME_STATE.PLAYING) {
                levelGroup.children.forEach(child => {
                    if (child.userData && child.userData.type === SURFACE.ACID) {
                        const time = Date.now() * 0.001;
                        const offset = child.userData.animOffset || 0;
                        child.position.y = -0.25 + Math.sin(time + offset) * 0.05;
                    }
                });
            }
        }

        function updateCamera() {
            if (marble && gameState === GAME_STATE.PLAYING) {
                cameraTargetPosition.copy(marble.position);
                cameraTargetPosition.y = 0;
                camera.position.x += (cameraTargetPosition.x - camera.position.x + SETTINGS.cameraDistance) * cameraSmoothing;
                camera.position.z += (cameraTargetPosition.z - camera.position.z + SETTINGS.cameraDistance) * cameraSmoothing;
                camera.position.y = SETTINGS.cameraDistance;
                camera.lookAt(marble.position);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (gameState === GAME_STATE.PLAYING) {
                updateMarblePhysics();
                updateEnemies();
                updateAcidAnimation();
                updateTimer();
                updateCamera();
            }
            
            if (marble) {
                marble.rotation.x += marbleVelocity.z * 2;
                marble.rotation.z -= marbleVelocity.x * 2;
            }
            
            renderer.render(scene, camera);
        }

        window.addEventListener('load', init);
        if (document.readyState === 'complete') init();
    </script>
</body>
</html>