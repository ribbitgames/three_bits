<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Shooter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #000;
            color: #fff;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #ui-container {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
        }

        #top-ui {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
        }

        #score, #lives, #level {
            font-size: 16px;
            text-shadow: 1px 1px 2px #000;
        }

        #boss-health-container {
            position: absolute;
            top: 50px;
            width: 100%;
            text-align: center;
            display: none;
        }

        #boss-health-bar {
            width: 200px;
            height: 20px;
            background-color: #333;
            border: 2px solid #fff;
            margin: 0 auto;
            overflow: hidden;
        }

        #boss-health {
            height: 100%;
            background-color: #ff0000;
            width: 100%;
            transition: width 0.2s;
        }

        #control-container {
            display: flex;
            justify-content: flex-end;
            align-items: flex-end;
            flex-grow: 1;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 20;
            cursor: pointer;
        }

        .hidden {
            display: none !important;
        }

        #start-button, #restart-button {
            background-color: #0f0;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-size: 18px;
            margin-top: 20px;
            cursor: pointer;
            border-radius: 5px;
        }

        #start-button:hover, #restart-button:hover {
            background-color: #0c0;
        }

        @media (max-width: 480px) {
            #top-ui {
                padding: 5px;
            }
            
            #score, #lives, #level {
                font-size: 14px;
            }

            #boss-health-bar {
                width: 150px;
                height: 15px;
            }
        }

        @media (min-width: 768px) {
            #top-ui {
                width: auto;
                max-width: 400px;
                margin: 0 auto;
            }

            #boss-health-bar {
                width: 300px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-canvas"></div>
        <div id="ui-container">
            <div id="top-ui">
                <div id="score">Score: 0</div>
                <div id="level">Level: 1</div>
                <div id="lives">Lives: 3</div>
            </div>
            <div id="boss-health-container">
                <div id="boss-health-bar">
                    <div id="boss-health"></div>
                </div>
            </div>
            <div id="control-container">
            </div>
        </div>
        <div id="start-screen">
            <h1>SPACE SHOOTER</h1>
            <button id="start-button">START GAME</button>
        </div>
        <div id="game-over-screen" class="hidden">
            <h1>GAME OVER</h1>
            <div>Final Score: <span id="final-score">0</span></div>
            <button id="restart-button">PLAY AGAIN</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        /**
         * Space Shooter using Three.js
         * Optimized for vertical phone screens, with touch/mouse controls
         * Includes boss fights with varied shapes, despawned enemies, and adjusted scoring
         */

        // Game state and constants
        const GAME_STATE = {
            INIT: 0,
            PLAYING: 1,
            GAME_OVER: 2
        };

        // Game configuration
        const CONFIG = {
            playerSpeed: 0.15,
            bulletSpeed: 0.5,
            enemySpeed: 0.05,
            powerUpChance: 0.5,
            enemySpawnRate: 1000,
            maxPlayerLives: 3,
            playerInvincibleTime: 2000,
            fireRate: 200,
            specialEnemyChance: 0.1,
            obstacleSpawnRate: 5000,
            obstacleSpeed: 0.03,
            enemyProjectileSpeed: 0.15,
            enemyFireRate: 2000,
            missileMinScore: 1000
        };

        // Game objects and variables
        let scene, camera, renderer, raycaster;
        let gameState = GAME_STATE.INIT;
        let lastTime = 0;
        let score = 0;
        let lives = CONFIG.maxPlayerLives;
        let player, playerLight, boss;
        let playerPowerUps = {
            speed: 0,
            missile: false,
            double: false,
            laser: false,
            shield: false
        };
        let bossActive = false;
        let nextBossScore = 3000; // Increased initial boss spawn
        let level = 1;
        let bossMaxHealth = 0;
        let bossShapeIndex = 0;

        // Boss shapes array
        const bossShapes = [
            new THREE.OctahedronGeometry(0.8),
            new THREE.BoxGeometry(1, 1, 1),
            new THREE.SphereGeometry(0.8, 16, 16),
            new THREE.TetrahedronGeometry(1),
            new THREE.TorusGeometry(0.6, 0.2, 16, 32)
        ];

        // Game object collections
        let bullets = [];
        let enemies = [];
        let powerUps = [];
        let explosions = [];
        let obstacles = [];
        let enemyProjectiles = [];

        // Timers and flags
        let lastEnemySpawn = 0;
        let lastFireTime = 0;
        let lastObstacleSpawn = 0;
        let isPointerDown = false;
        let playerInvincible = false;
        let playerInvincibleTimer = 0;
        let gameInitialized = false;

        // Screen dimensions and scaling
        let screenWidth, screenHeight, aspectRatio;
        let gameScale = 1;

        /**
         * Initialize game on DOM load
         */
        document.addEventListener('DOMContentLoaded', () => {
            console.log("Document loaded");

            const startButton = document.getElementById('start-button');
            if (startButton) {
                startButton.addEventListener('click', () => {
                    console.log("Start button clicked");
                    if (gameState === GAME_STATE.INIT) {
                        startGame();
                    }
                });
            }

            const restartButton = document.getElementById('restart-button');
            if (restartButton) {
                restartButton.addEventListener('click', () => {
                    resetGame();
                });
            }

            if (!gameInitialized) {
                init();
                gameInitialized = true;
            }
        });

        function init() {
            updateScreenDimensions();

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000025);

            setupCamera();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(screenWidth, screenHeight);
            document.getElementById('game-canvas').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x333333);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(0, 0, 5);
            scene.add(dirLight);

            raycaster = new THREE.Raycaster();

            window.addEventListener('resize', onWindowResize);

            renderer.domElement.addEventListener('mousedown', onPointerDown);
            renderer.domElement.addEventListener('touchstart', onPointerDown, { passive: false });

            renderer.domElement.addEventListener('mousemove', onPointerMove);
            renderer.domElement.addEventListener('touchmove', onPointerMove, { passive: false });

            renderer.domElement.addEventListener('mouseup', onPointerUp);
            renderer.domElement.addEventListener('touchend', onPointerUp);

            renderer.domElement.addEventListener('mouseleave', onPointerUp);
            renderer.domElement.addEventListener('touchcancel', onPointerUp);

            createPlayer();
            createStarfield();

            document.getElementById('start-screen').classList.remove('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');

            updateScoreDisplay();
            updateLevelDisplay();
            updateLivesDisplay();

            animate(0);
        }

        function updateScreenDimensions() {
            screenWidth = window.innerWidth;
            screenHeight = window.innerHeight;
            aspectRatio = screenHeight / screenWidth;
            gameScale = screenWidth < 480 ? 0.8 : 1;
        }

        function setupCamera() {
            const frustumSize = 10;
            camera = new THREE.OrthographicCamera(
                frustumSize / -2,
                frustumSize / 2,
                (frustumSize * aspectRatio) / 2,
                (frustumSize * aspectRatio) / -2,
                1,
                1000
            );
            camera.position.z = 10;
        }

        function createPlayer() {
            const shipGroup = new THREE.Group();

            const bodyGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.4, 8);
            bodyGeometry.rotateX(Math.PI / 2);
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: 0x3030ff,
                emissive: 0x101080,
                shininess: 50,
                flatShading: false
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            shipGroup.add(body);

            const noseGeometry = new THREE.ConeGeometry(0.15, 0.2, 8);
            noseGeometry.rotateX(-Math.PI / 2);
            const nose = new THREE.Mesh(noseGeometry, bodyMaterial);
            nose.position.set(0, 0.3, 0);
            shipGroup.add(nose);

            const cockpitGeometry = new THREE.SphereGeometry(0.12, 8, 8);
            const cockpitMaterial = new THREE.MeshPhongMaterial({
                color: 0x2020a0,
                emissive: 0x101060,
                shininess: 80,
                flatShading: false
            });
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.position.set(0, 0.05, 0.05);
            cockpit.scale.set(0.7, 1, 0.7);
            shipGroup.add(cockpit);

            const wingGeometry = new THREE.BoxGeometry(0.5, 0.05, 0.3);
            const wingMaterial = new THREE.MeshPhongMaterial({
                color: 0x3040c0,
                emissive: 0x101060,
                shininess: 30,
                flatShading: true
            });
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-0.15, 0, -0.05);
            shipGroup.add(leftWing);
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(0.15, 0, -0.05);
            shipGroup.add(rightWing);

            const engineGeometry = new THREE.CylinderGeometry(0.05, 0.08, 0.1, 8);
            const engineMaterial = new THREE.MeshPhongMaterial({
                color: 0xff5500,
                emissive: 0xff2200,
                shininess: 100,
                flatShading: false
            });
            const leftEngine = new THREE.Mesh(engineGeometry, engineMaterial);
            leftEngine.position.set(-0.1, -0.25, 0);
            shipGroup.add(leftEngine);
            const rightEngine = new THREE.Mesh(engineGeometry, engineMaterial);
            rightEngine.position.set(0.1, -0.25, 0);
            shipGroup.add(rightEngine);

            const engineLight = new THREE.PointLight(0xff5500, 1, 1);
            engineLight.position.set(0, -0.3, 0);
            shipGroup.add(engineLight);

            player = shipGroup;
            player.position.set(0, -6, 0);
            scene.add(player);

            playerLight = new THREE.PointLight(0x3030ff, 1, 3);
            playerLight.position.copy(player.position);
            scene.add(playerLight);

            const shieldGeometry = new THREE.SphereGeometry(0.4, 8, 8);
            const shieldMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.3,
                wireframe: true
            });
            player.shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
            player.shield.visible = false;
            player.add(player.shield);
        }

        function createStarfield() {
            const layerCount = 3;
            const starCounts = [100, 80, 60];
            const starSpeeds = [0.02, 0.05, 0.1];
            const starSizes = [0.02, 0.03, 0.05];
            window.starLayers = [];

            for (let layer = 0; layer < layerCount; layer++) {
                const starCount = starCounts[layer];
                const starGeometry = new THREE.BufferGeometry();
                const starPositions = new Float32Array(starCount * 3);

                for (let i = 0; i < starCount; i++) {
                    const i3 = i * 3;
                    starPositions[i3] = Math.random() * 16 - 8;
                    starPositions[i3 + 1] = Math.random() * 20 - 10;
                    starPositions[i3 + 2] = -5 - layer * 2;
                }

                starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
                const starMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: starSizes[layer],
                    transparent: true,
                    opacity: 0.8,
                    sizeAttenuation: true
                });
                const stars = new THREE.Points(starGeometry, starMaterial);
                stars.scrollSpeed = starSpeeds[layer];
                stars.positions = starPositions;
                scene.add(stars);
                window.starLayers.push(stars);
            }
        }

        function onWindowResize() {
            updateScreenDimensions();
            const frustumSize = 10;
            camera.left = frustumSize / -2;
            camera.right = frustumSize / 2;
            camera.top = (frustumSize * aspectRatio) / 2;
            camera.bottom = (frustumSize * aspectRatio) / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(screenWidth, screenHeight);
        }

        function onPointerDown(event) {
            event.preventDefault();
            if (gameState === GAME_STATE.PLAYING) {
                isPointerDown = true;
                updatePlayerTarget(event);
                firePlayerWeapon();
            }
        }

        function onPointerMove(event) {
            event.preventDefault();
            if (gameState !== GAME_STATE.PLAYING || !isPointerDown) return;
            updatePlayerTarget(event);
        }

        function onPointerUp(event) {
            if (event.preventDefault) {
                event.preventDefault();
            }
            isPointerDown = false;
        }

        function updatePlayerTarget(event) {
            const pointer = {};
            if (event.type.startsWith('touch')) {
                pointer.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
                pointer.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
            } else {
                pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
                pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
            }
            const vector = new THREE.Vector3(pointer.x, pointer.y, 0);
            vector.unproject(camera);
            player.targetX = vector.x;
        }

        function startGame() {
            console.log("startGame called, changing state to PLAYING");
            gameState = GAME_STATE.PLAYING;
            score = 0;
            lives = CONFIG.maxPlayerLives;
            playerPowerUps = {
                speed: 0,
                missile: false,
                double: false,
                laser: false,
                shield: false
            };
            bossActive = false;
            nextBossScore = 3000;
            level = 1;
            bossShapeIndex = 0;
            clearGameObjects();
            player.position.set(0, -6, 0);
            player.shield.visible = false;
            updateScoreDisplay();
            updateLevelDisplay();
            updateLivesDisplay();
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('boss-health-container').style.display = 'none';
        }

        function resetGame() {
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('boss-health-container').style.display = 'none';
            startGame();
        }

        function clearGameObjects() {
            bullets.forEach(bullet => scene.remove(bullet));
            bullets = [];
            enemies.forEach(enemy => scene.remove(enemy));
            enemies = [];
            powerUps.forEach(powerUp => scene.remove(powerUp));
            powerUps = [];
            explosions.forEach(explosion => scene.remove(explosion));
            explosions = [];
            obstacles.forEach(obstacle => scene.remove(obstacle));
            obstacles = [];
            enemyProjectiles.forEach(projectile => scene.remove(projectile));
            enemyProjectiles = [];
            if (bossActive && boss) {
                scene.remove(boss);
                bossActive = false;
            }
        }

        function gameOver() {
            gameState = GAME_STATE.GAME_OVER;
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('boss-health-container').style.display = 'none';
        }

        function updateScoreDisplay() {
            document.getElementById('score').textContent = `Score: ${score}`;
        }

        function updateLevelDisplay() {
            document.getElementById('level').textContent = `Level: ${level}`;
        }

        function updateLivesDisplay() {
            document.getElementById('lives').textContent = `Lives: ${lives}`;
        }

        function updateBossHealthBar() {
            if (bossActive && boss) {
                const healthPercentage = (boss.health / bossMaxHealth) * 100;
                document.getElementById('boss-health').style.width = `${healthPercentage}%`;
                document.getElementById('boss-health-container').style.display = 'block';
            } else {
                document.getElementById('boss-health-container').style.display = 'none';
            }
        }

        function spawnEnemy() {
            const isSpecialEnemy = Math.random() < CONFIG.specialEnemyChance;
            const enemyTypes = isSpecialEnemy ? [
                {
                    geometry: new THREE.OctahedronGeometry(0.4),
                    color: 0x00ff00,
                    emissive: 0x005500,
                    health: 5,
                    score: 500,
                    isSpecial: true,
                    canShoot: true
                }
            ] : [
                {
                    geometry: new THREE.BoxGeometry(0.3, 0.3, 0.3),
                    color: 0xff0000,
                    emissive: 0x500000,
                    health: 1,
                    score: 100,
                    isSpecial: false,
                    canShoot: false
                },
                {
                    geometry: new THREE.SphereGeometry(0.2, 8, 8),
                    color: 0xff5500,
                    emissive: 0x551500,
                    health: 2,
                    score: 200,
                    isSpecial: false,
                    canShoot: false
                },
                {
                    geometry: new THREE.TetrahedronGeometry(0.25),
                    color: 0xff0055,
                    emissive: 0x550015,
                    health: 3,
                    score: 300,
                    isSpecial: false,
                    canShoot: false
                }
            ];
            const enemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
            const material = new THREE.MeshPhongMaterial({
                color: enemyType.color,
                emissive: enemyType.emissive,
                shininess: 30
            });
            const enemy = new THREE.Mesh(enemyType.geometry, material);
            enemy.position.set(
                Math.random() * 8 - 4,
                7,
                0
            );
            enemy.health = enemyType.health;
            enemy.score = enemyType.score;
            enemy.speed = CONFIG.enemySpeed * (1 + level * 0.1);
            enemy.isSpecial = enemyType.isSpecial;
            enemy.canShoot = enemyType.canShoot;
            enemy.lastShotTime = 0;
            scene.add(enemy);
            enemies.push(enemy);
        }

        function spawnBoss() {
            // Despawn existing enemies
            enemies.forEach(enemy => scene.remove(enemy));
            enemies = [];

            const bossGeometry = bossShapes[bossShapeIndex];
            const bossMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, emissive: 0x550000 });
            boss = new THREE.Mesh(bossGeometry, bossMaterial);
            boss.position.set(0, 5, 0);
            bossMaxHealth = 50 * level;
            boss.health = bossMaxHealth;
            boss.score = 500 * level;
            boss.speed = 0.02;
            boss.lastShotTime = 0;
            boss.attackInterval = 2000 / level;
            scene.add(boss);
            bossActive = true;
            updateBossHealthBar();
            bossShapeIndex = (bossShapeIndex + 1) % bossShapes.length; // Cycle shapes
        }

        function spawnObstacle() {
            const isRectangle = Math.random() < 0.5;
            const obstacleGeometry = isRectangle
                ? new THREE.BoxGeometry(0.8, 0.4, 0.4)
                : new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const obstacleMaterial = new THREE.MeshPhongMaterial({
                color: 0x555555,
                emissive: 0x222222,
                shininess: 10
            });
            const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            obstacle.position.set(
                Math.random() * 8 - 4,
                7,
                0
            );
            obstacle.speed = CONFIG.obstacleSpeed;
            scene.add(obstacle);
            obstacles.push(obstacle);
        }

        function firePlayerWeapon() {
            const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletColor = playerPowerUps.laser ? 0xff00ff : 0x00ffff;
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: bulletColor });

            function createBullet(offsetX = 0) {
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                bullet.position.set(player.position.x + offsetX, player.position.y + 0.3, 0);
                bullet.speed = CONFIG.bulletSpeed;
                bullet.power = playerPowerUps.laser ? 2 : 1;
                scene.add(bullet);
                bullets.push(bullet);
            }

            createBullet();
            if (playerPowerUps.double) {
                createBullet(0.2);
                createBullet(-0.2);
            }

            if (playerPowerUps.missile) {
                const missileGeometry = new THREE.ConeGeometry(0.1, 0.2, 4);
                missileGeometry.rotateX(-Math.PI / 2);
                const missileMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
                const missile = new THREE.Mesh(missileGeometry, missileMaterial);
                missile.position.set(player.position.x - 0.3, player.position.y, 0);
                missile.speed = CONFIG.bulletSpeed * 0.7;
                missile.power = 0.9;
                missile.isMissile = true;
                scene.add(missile);
                bullets.push(missile);
            }
        }

        function fireEnemyProjectile(enemy) {
            const projectileGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const projectileMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            projectile.position.set(enemy.position.x, enemy.position.y - 0.3, 0);
            projectile.speed = CONFIG.enemyProjectileSpeed;
            scene.add(projectile);
            enemyProjectiles.push(projectile);
            enemy.lastShotTime = performance.now();
        }

        function fireBossProjectiles() {
            const angles = [-15, 0, 15];
            angles.forEach(angle => {
                const rad = angle * Math.PI / 180;
                const projectile = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
                projectile.position.copy(boss.position);
                projectile.velocity = {
                    x: Math.sin(rad) * CONFIG.enemyProjectileSpeed,
                    y: -Math.cos(rad) * CONFIG.enemyProjectileSpeed
                };
                scene.add(projectile);
                enemyProjectiles.push(projectile);
            });
        }

        function collectPowerUp(powerUp) {
            let powerTypes = ['speed', 'double', 'laser', 'shield'];
            if (score >= CONFIG.missileMinScore) {
                powerTypes.push('missile');
            }
            const powerType = powerTypes[Math.floor(Math.random() * powerTypes.length)];
            applyPowerUp(powerType);
            scene.remove(powerUp);
            powerUps.splice(powerUps.indexOf(powerUp), 1);
        }

        function applyPowerUp(powerType) {
            switch (powerType) {
                case 'speed':
                    playerPowerUps.speed = Math.min(playerPowerUps.speed + 1, 3);
                    break;
                case 'missile':
                    playerPowerUps.missile = true;
                    break;
                case 'double':
                    playerPowerUps.double = true;
                    break;
                case 'laser':
                    playerPowerUps.laser = true;
                    break;
                case 'shield':
                    playerPowerUps.shield = true;
                    player.shield.visible = true;
                    break;
            }
        }

        function createExplosion(position, size = 1, color = 0xffaa00) {
            const particleCount = 10;
            const explosionGeometry = new THREE.BufferGeometry();
            const explosionPositions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                explosionPositions[i3] = position.x;
                explosionPositions[i3 + 1] = position.y;
                explosionPositions[i3 + 2] = position.z;
            }

            explosionGeometry.setAttribute('position', new THREE.BufferAttribute(explosionPositions, 3));
            const explosionMaterial = new THREE.PointsMaterial({
                color: color,
                size: 0.1 * size,
                transparent: true,
                opacity: 1
            });
            const explosion = new THREE.Points(explosionGeometry, explosionMaterial);
            explosion.userData.age = 0;
            explosion.userData.size = size;
            explosion.userData.particlePositions = explosionPositions;
            scene.add(explosion);
            explosions.push(explosion);
        }

        function updateBoss(delta, time) {
            boss.position.x = 3 * Math.sin(time * 0.001);
            boss.position.y = 5; // Stay at top
            boss.rotation.y += delta * 0.5;
            if (time - boss.lastShotTime > boss.attackInterval) {
                fireBossProjectiles();
                boss.lastShotTime = time;
            }
        }

        function checkCollisions() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const distance = bullet.position.distanceTo(enemy.position);
                    if (distance < 0.3) {
                        enemy.health -= bullet.power;
                        scene.remove(bullet);
                        bullets.splice(i, 1);
                        createExplosion(bullet.position, 0.5, 0x00ffff);
                        if (enemy.health <= 0) {
                            score += enemy.score;
                            updateScoreDisplay();
                            createExplosion(enemy.position);
                            if (enemy.isSpecial && Math.random() < CONFIG.powerUpChance) {
                                createPowerUp(enemy.position);
                            }
                            scene.remove(enemy);
                            enemies.splice(j, 1);
                        }
                        break;
                    }
                }
            }

            if (bossActive) {
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const bullet = bullets[i];
                    const distance = bullet.position.distanceTo(boss.position);
                    if (distance < 0.8) {
                        boss.health -= bullet.power;
                        scene.remove(bullet);
                        bullets.splice(i, 1);
                        createExplosion(bullet.position, 0.7, 0xffff00); // Yellow hit effect
                        updateBossHealthBar();
                        if (boss.health <= 0) {
                            score += boss.score;
                            updateScoreDisplay();
                            createExplosion(boss.position, 2, 0xff0000);
                            scene.remove(boss);
                            bossActive = false;
                            level++;
                            nextBossScore = score + 3000; // Increased interval
                            updateLevelDisplay();
                            updateBossHealthBar();
                            if (Math.random() < 0.5) {
                                createPowerUp(boss.position);
                            }
                        }
                        break;
                    }
                }
                const playerBossDistance = player.position.distanceTo(boss.position);
                if (playerBossDistance < 1.0 && !playerInvincible) {
                    handlePlayerHit();
                    boss.health -= 10;
                    createExplosion(boss.position, 0.7, 0xffff00);
                    updateBossHealthBar();
                    if (boss.health <= 0) {
                        score += boss.score;
                        updateScoreDisplay();
                        createExplosion(boss.position, 2, 0xff0000);
                        scene.remove(boss);
                        bossActive = false;
                        level++;
                        nextBossScore = score + 3000; // Increased interval
                        updateLevelDisplay();
                        updateBossHealthBar();
                        if (Math.random() < 0.5) {
                            createPowerUp(boss.position);
                        }
                    }
                }
            }

            if (playerInvincible) return;

            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const distance = player.position.distanceTo(enemy.position);
                if (distance < 0.4) {
                    createExplosion(enemy.position);
                    scene.remove(enemy);
                    enemies.splice(i, 1);
                    handlePlayerHit();
                    break;
                }
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                const distance = player.position.distanceTo(obstacle.position);
                if (distance < 0.5) {
                    handlePlayerHit();
                    break;
                }
            }

            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                const distance = player.position.distanceTo(powerUp.position);
                if (distance < 0.4) {
                    collectPowerUp(powerUp);
                }
            }

            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const projectile = enemyProjectiles[i];
                const distance = player.position.distanceTo(projectile.position);
                if (distance < 0.3) {
                    scene.remove(projectile);
                    enemyProjectiles.splice(i, 1);
                    handlePlayerHit();
                    break;
                }
            }
        }

        function handlePlayerHit() {
            if (playerPowerUps.shield) {
                playerPowerUps.shield = false;
                player.shield.visible = false;
                createExplosion(player.position, 1, 0x00ffff);
                playerInvincible = true;
                playerInvincibleTimer = CONFIG.playerInvincibleTime / 2;
                return;
            }
            lives--;
            updateLivesDisplay();
            createExplosion(player.position, 1.5, 0x3030ff);
            if (lives <= 0) {
                gameOver();
                return;
            }
            playerInvincible = true;
            playerInvincibleTimer = CONFIG.playerInvincibleTime;
            player.position.set(0, -6, 0);
        }

        function createPowerUp(position) {
            const powerUpGeometry = new THREE.OctahedronGeometry(0.15);
            const powerUpMaterial = new THREE.MeshPhongMaterial({
                color: 0xffff00,
                emissive: 0x555500,
                shininess: 80
            });
            const powerUp = new THREE.Mesh(powerUpGeometry, powerUpMaterial);
            powerUp.position.copy(position);
            scene.add(powerUp);
            powerUps.push(powerUp);
        }

        function animate(time) {
            requestAnimationFrame(animate);
            const delta = lastTime ? (time - lastTime) / 1000 : 0;
            lastTime = time;
            if (gameState === GAME_STATE.PLAYING) {
                updateGame(delta, time);
            }
            renderer.render(scene, camera);
        }

        function updateGame(delta, time) {
            if (player.targetX !== undefined) {
                const playerSpeedFactor = 1 + (playerPowerUps.speed * 0.5);
                const targetDistance = player.targetX - player.position.x;
                const moveStep = CONFIG.playerSpeed * playerSpeedFactor * delta * 60;
                if (Math.abs(targetDistance) > moveStep) {
                    player.position.x += Math.sign(targetDistance) * moveStep;
                } else {
                    player.position.x = player.targetX;
                }
                player.position.x = Math.max(-4.5, Math.min(4.5, player.position.x));
            }

            playerLight.position.copy(player.position);

            if (isPointerDown && gameState === GAME_STATE.PLAYING) {
                const currentTime = performance.now();
                if (currentTime - lastFireTime >= CONFIG.fireRate) {
                    firePlayerWeapon();
                    lastFireTime = currentTime;
                }
            }

            if (playerInvincible) {
                playerInvincibleTimer -= delta * 1000;
                player.visible = Math.floor(time / 100) % 2 === 0;
                if (playerInvincibleTimer <= 0) {
                    playerInvincible = false;
                    player.visible = true;
                }
            }

            if (window.starLayers) {
                window.starLayers.forEach(starLayer => {
                    const positions = starLayer.positions;
                    const count = positions.length / 3;
                    for (let i = 0; i < count; i++) {
                        const i3 = i * 3;
                        positions[i3 + 1] -= starLayer.scrollSpeed * delta * 60;
                        if (positions[i3 + 1] < -10) {
                            positions[i3 + 1] = 10;
                            positions[i3] = Math.random() * 16 - 8;
                        }
                    }
                    starLayer.geometry.attributes.position.needsUpdate = true;
                });
            }

            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.position.y += bullet.speed * delta * 60;
                if (bullet.isMissile && enemies.length > 0) {
                    let closestEnemy = null;
                    let closestDistance = Infinity;
                    for (const enemy of enemies) {
                        if (enemy.position.y > bullet.position.y) {
                            const distance = bullet.position.distanceTo(enemy.position);
                            if (distance < closestDistance) {
                                closestDistance = distance;
                                closestEnemy = enemy;
                            }
                        }
                    }
                    if (closestEnemy && closestDistance < 5) {
                        const targetX = closestEnemy.position.x;
                        const xDiff = targetX - bullet.position.x;
                        bullet.position.x += Math.sign(xDiff) * bullet.speed * 0.5 * delta * 60;
                    }
                }
                if (bullet.position.y > 6) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                }
            }

            if (!bossActive) {
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    enemy.position.y -= enemy.speed * delta * 60;
                    enemy.position.x += Math.sin(time * 0.001 + enemy.position.y) * enemy.speed * 0.5 * delta * 60;
                    enemy.rotation.x += delta;
                    enemy.rotation.z += delta * 0.5;
                    if (enemy.canShoot && performance.now() - enemy.lastShotTime >= CONFIG.enemyFireRate) {
                        fireEnemyProjectile(enemy);
                    }
                    if (enemy.position.y < -6) {
                        scene.remove(enemy);
                        enemies.splice(i, 1);
                    }
                }
            }

            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                powerUp.position.y -= CONFIG.enemySpeed * 0.5 * delta * 60;
                powerUp.rotation.x += delta * 2;
                powerUp.rotation.y += delta * 2;
                powerUp.rotation.z += delta * 2;
                if (powerUp.position.y < -6) {
                    scene.remove(powerUp);
                    powerUps.splice(i, 1);
                }
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                obstacle.position.y -= obstacle.speed * delta * 60;
                obstacle.rotation.x += delta * 0.5;
                obstacle.rotation.y += delta * 0.5;
                if (obstacle.position.y < -6) {
                    scene.remove(obstacle);
                    obstacles.splice(i, 1);
                }
            }

            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const projectile = enemyProjectiles[i];
                if (projectile.velocity) {
                    projectile.position.x += projectile.velocity.x * delta * 60;
                    projectile.position.y += projectile.velocity.y * delta * 60;
                } else {
                    projectile.position.y -= projectile.speed * delta * 60;
                }
                if (projectile.position.y < -6 || Math.abs(projectile.position.x) > 6) {
                    scene.remove(projectile);
                    enemyProjectiles.splice(i, 1);
                }
            }

            checkCollisions();

            if (score >= nextBossScore && !bossActive) {
                spawnBoss();
            }

            if (bossActive) {
                updateBoss(delta, time);
            } else if (time - lastEnemySpawn > CONFIG.enemySpawnRate) {
                spawnEnemy();
                lastEnemySpawn = time;
                CONFIG.enemySpawnRate = Math.max(300, CONFIG.enemySpawnRate - 5);
            }

            if (time - lastObstacleSpawn > CONFIG.obstacleSpawnRate) {
                spawnObstacle();
                lastObstacleSpawn = time;
            }
        }
    </script>
</body>
</html>